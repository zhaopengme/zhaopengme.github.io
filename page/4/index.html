<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="http://cdn.zhaopeng.me/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link href="//cdn.bootcss.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">

<link rel="stylesheet" type="text/css" href="http://cdn.zhaopeng.me/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="北冥大鸟" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="北冥大鸟">
<meta property="og:url" content="http://zhaopeng.me/page/4/index.html">
<meta property="og:site_name" content="北冥大鸟">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="北冥大鸟">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 北冥大鸟 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">北冥大鸟</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">赵鹏的书院</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
        <li class="menu-item menu-item-search">
          <a href="#" class="st-search-show-outputs">
            
              <i class="menu-item-icon fa fa-search icon-next-search"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'KKy7kMLzqcedsP4uzFVg','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/1/5/dong-wu-zhi-hun/" itemprop="url">
                  动物之魂
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-01-05T18:31:13+08:00" content="2015-01-05">
              2015-01-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/摄影/" itemprop="url" rel="index">
                    <span itemprop="name">摄影</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/1/5/dong-wu-zhi-hun/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/1/5/dong-wu-zhi-hun/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <!--StartFragment-->动物之魂。丨俄罗斯插画家 Alexandra Khitrova 的空灵系列插画.<!--EndFragment-->
<p><a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_9.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_9.jpg" alt="WeiboImg20140623_153337_9"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_1.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_1.jpg" alt="WeiboImg20140623_153337_1"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_2.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_2.jpg" alt="WeiboImg20140623_153337_2"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_3.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_3.jpg" alt="WeiboImg20140623_153337_3"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_4.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_4.jpg" alt="WeiboImg20140623_153337_4"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_5.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_5-704x1024.jpg" alt="WeiboImg20140623_153337_5"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_6.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_6.jpg" alt="WeiboImg20140623_153337_6"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_7.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_7.jpg" alt="WeiboImg20140623_153337_7"></a> <a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_8.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/WeiboImg20140623_153337_8.jpg" alt="WeiboImg20140623_153337_8"></a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2015/1/1/hello2015/" itemprop="url">
                  hello 2015
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-01-01T00:09:30+08:00" content="2015-01-01">
              2015-01-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/闲言碎语/" itemprop="url" rel="index">
                    <span itemprop="name">闲言碎语</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/1/1/hello2015/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/1/1/hello2015/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/12/2015.jpg" alt=""></p>
<p>hello 2015,我们在上线!</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/12/28/shu-ju-ku-she-ji-yuan-ze/" itemprop="url">
                  数据库设计原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-12-28T21:43:38+08:00" content="2014-12-28">
              2014-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/资料文档/" itemprop="url" rel="index">
                    <span itemprop="name">资料文档</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/28/shu-ju-ku-she-ji-yuan-ze/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/28/shu-ju-ku-she-ji-yuan-ze/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>从<!--StartFragment--><a href="http://weibo.com/rebol" target="_blank" rel="external">@蔡学镛</a>看到的数据库的一些设计原则,可以考虑考虑.<!--EndFragment--></p>
<p>1.</p>
<p><!--StartFragment-->梳理数据库时，你会很惊讶地发现，各种数据都被塞进数据库，所以做数据库梳理的第一步是把它们区分出来，我的区分方式是：核心数据、业务数据、核心缓存数据、业务缓存数据、Session 数据。核心数据及其缓存都要再根据领域（domain）来区分，业务数据及其缓存都要再根据业务（business）来区分。</p>
<p>2.</p>
<p>梳理数据库或设计数据存储时,可以考虑数据的属性：</p>
<p>1. 访问频率 (高/中/低)</p>
<p>2. 读写比 (只读/读多/读少)</p>
<p>3. 重要性 (重要/普通/不重要)</p>
<p>4. 保密性 (保密/普通/不需保密)</p>
<p>5. 数据笔数 (多/一般/少)</p>
<p>6. 数据体积 (大/中/小)</p>
<p>7. 一致性要求 (强/中/弱)</p>
<p>8. 热点现象 (强/中/弱)</p>
<p>9. 索引方式 ( <em>__</em> )</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/12/28/doublecookie-yan-zheng/" itemprop="url">
                  double cookie验证
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-12-28T19:53:26+08:00" content="2014-12-28">
              2014-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/资料文档/" itemprop="url" rel="index">
                    <span itemprop="name">资料文档</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/28/doublecookie-yan-zheng/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/28/doublecookie-yan-zheng/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>from: <a href="http://www.75team.com/archives/729" target="_blank" rel="external">http://www.75team.com/archives/729</a></p>
<p>什么是double cookie验证<br>double cookie验证是利用cookie来验证请求合法性的一种方法。</p>
<p>一个double cookie验证的url形如</p>
<p><code>http://a.com?c=cookie</code></p>
<p>向服务器请求的url带上cookie，服务器收到请求后，解析出url中的cookie和http请求带过来的cookie进行对比。如果一样就说明请求合法，不一样就可以判定请求非法。</p>
<p>因为是用url中的cookie和http请求中的cookie进行验证，所以叫double cookie验证。</p>
<p>验证原理</p>
<p>url是客户端javascript生成的，javascript可以读取cookie。</p>
<p>url可以从任意客户端访问，但是只有一个客户端的http请求带给服务器的cookie和url中的cookie是一致的。</p>
<p>注意事项</p>
<ul>
<li>用来验证的cookie在每个客户端必须唯一</li>
<li>用来验证的cookie不能是敏感信息。比如登录用户的token不能作为验证的cookie<br>应用场景</li>
</ul>
<p>double cookie验证不能判断用户修改本地cookie然后再进行的访问。但是没有关系。举个应用场景。</p>
<p>比如一个网站的 评分功能的请求是这样的</p>
<p><code>http://a.com?score=100&amp;amp;id=10000</code></p>
<p>如果有人把这个url发到网上，引诱其它用户来点击，那么就会生成大量的评分请求。这时就可以用double cookie验证了。因为很难让点击这个链接的人先修改本地cookie然后再点击链接</p>
<p>使用建议</p>
<p>有的同学喜欢把cookie做个变换，防止别人一眼看出来是用哪个cookie做的验证。没必要这样做，也不应该这样做。</p>
<ol>
<li>变换的方法一定会暴露在客户端</li>
<li>验证的目的不是为了防止有意伪造</li>
<li>对cooie做变换的方法如果不得当，可能会对cookie的结构造成依赖。如果哪天cookie的结构改变了，就会使验证代码失效，甚至报错。</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/12/28/web-an-quan-zhi-sql-zhu-ru-gong-ji-ji-qiao-yu-fang-fan/" itemprop="url">
                  Web安全之SQL注入攻击技巧与防范
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-12-28T15:18:41+08:00" content="2014-12-28">
              2014-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/资料文档/" itemprop="url" rel="index">
                    <span itemprop="name">资料文档</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/28/web-an-quan-zhi-sql-zhu-ru-gong-ji-ji-qiao-yu-fang-fan/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/28/web-an-quan-zhi-sql-zhu-ru-gong-ji-ji-qiao-yu-fang-fan/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>from: <a href="http://www.plhwin.com/2014/06/13/web-security-sql/" target="_blank" rel="external">http://www.plhwin.com/2014/06/13/web-security-sql/</a></p>
<h1 id="Web安全简史">Web安全简史</h1><p>在Web1.0时代，人们更多是关注服务器端动态脚本语言的安全问题，比如将一个可执行脚本（俗称Webshell）通过脚本语言的漏洞上传到服务器上，从而获得服务器权限。在Web发展初期，随着动态脚本语言的发展和普及，以及早期工程师对安全问题认知不足导致很多”安全血案”的发生，至今仍然遗留下许多历史问题，比如PHP语言至今仍然无法从语言本身杜绝「文件包含漏洞」（<a href="http://developer.51cto.com/art/201104/255224.htm" target="_blank" rel="external">参见这里</a>），只能依靠工程师良好的代码规范和安全意识。</p>
<p>伴随着Web2.0、社交网络、微博等一系列新型互联网产品的兴起，基于Web环境的互联网应用越来越广泛，Web攻击的手段也越来越多样，Web安全史上的一个重要里程碑是大约1999年发现的SQL注入攻击，之后的XSS，CSRF等攻击手段愈发强大，Web攻击的思路也从服务端转向了客户端，转向了浏览器和用户。</p>
<p>在安全领域，一般用帽子的颜色来比喻黑客的善与恶，白帽子是指那些工作在反黑客领域的技术专家，这个群体是”善”的的象征；而黑帽子则是指那些利用黑客技术造成破坏甚至谋取私利造成犯罪的群体，他们是”恶”的代表。</p>
<p>“白帽子”和”黑帽子”是两个完全对立的群体。对于黑帽子而言，他们只要找到系统的一个切入点就可以达到入侵破坏的目的，而白帽子必须将自己系统所有可能被突破的地方都设防，以保证系统的安全运行。</p>
<p>这看起来好像是不公平的，但是安全世界里的规则就是这样，可能我们的网站1000处都布防的很好，考虑的很周到，但是只要有一个地方疏忽了，攻击者就会利用这个点进行突破，让我们另外的1000处努力白费。</p>
<h1 id="常见攻击方式">常见攻击方式</h1><p>一般说来，在Web安全领域，常见的攻击方式大概有以下几种：<br>1、SQL注入攻击<br>2、跨站脚本攻击 - XSS<br>3、跨站伪造请求攻击 - CSRF<br>4、文件上传漏洞攻击<br>5、分布式拒绝服务攻击 - DDOS</p>
<p>说个题外话，本来这篇文章一开始的标题叫做 「Web安全之常见攻击方法与防范」，我原本想把上面的这5种方法都全部写在一篇文章里，可是刚写完第一个SQL注入攻击的时候，就发现文章篇幅已经不短了，又很难再进行大幅度的精简，所以索性把Web安全分成一个系列，分多篇文章来呈现给大家，下面你看到的就是第一篇「Web安全之SQL注入攻击的技巧与防范」。</p>
<h1 id="SQL注入常见攻击技巧">SQL注入常见攻击技巧</h1><p>SQL注入攻击是Web安全史上的一个重要里程碑，它从1999年首次进入人们的视线，至今已经有十几年的历史了，虽然我们现在已经有了很全面的防范对策，但是它的威力仍然不容小觑，SQL注入攻击至今仍然是Web安全领域中的一个重要组成部分。</p>
<p>以PHP+MySQL为例，让我们以一个Web网站中最基本的用户系统来做实例演示，看看SQL注入究竟是怎么发生的。</p>
<p>1、创建一个名为demo的数据库：</p>
<figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>CREATE DATABASE  <code>demo</code> DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</pre><br></td><br></tr><br></tbody><br></table><br></figure>2、创建一个名为user的数据表，并插入1条演示数据：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>CREATE TABLE  <code>demo</code>.<code>user</code> (<br><code>uid</code> INT( 11 ) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT  ‘用户uid’,<br><code>username</code> VARCHAR( 20 ) NOT NULL COMMENT  ‘用户名’,<br><code>password</code> VARCHAR( 32 ) NOT NULL COMMENT  ‘用户密码’<br>) ENGINE = INNODB;<br>INSERT INTO <code>demo</code>.<code>user</code> (<code>uid</code>, <code>username</code>, <code>password</code>) VALUES (‘1’, ‘plhwin’, MD5(‘123456’));</pre><br></td><br></tr><br></tbody><br></table><br></figure>

<h2 id="实例一">实例一</h2><p>通过传入<code>username</code>参数，在页面打印出这个会员的详细信息，编写 <code>userinfo.php</code> 程序代码：</p>
<figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>&lt;?php<br>header(‘Content-type:text/html; charset=UTF-8’);<br>$username = isset($_GET[‘username’]) ? $_GET[‘username’] : ‘’;<br>$userinfo = array();<br>if($username){<br>    //使用mysqli驱动连接demo数据库<br>    $mysqli = new mysqli(“localhost”, “root”, “root”, ‘demo’);<br>    $sql = “SELECT uid,username FROM user WHERE username=’{$username}’”;<br>    //mysqli multi_query 支持执行多条MySQL语句<br>    $query = $mysqli-&gt;multi_query($sql);<br>    if($query){<br>        do {<br>            $result = $mysqli-&gt;store_result();<br>            while($row = $result-&gt;fetch_assoc()){<br>                $userinfo[] = $row;<br>            }<br>            if(!$mysqli-&gt;more_results()){<br>                break;<br>            }<br>        } while ($mysqli-&gt;next_result());<br>    }<br>}<br>echo ‘&lt;pre&gt;’,print_r($userinfo, 1),’&lt;/pre&gt;’;</pre><br></td><br></tr><br></tbody><br></table><br></figure>上面这个程序要实现的功能是根据浏览器传入的用户名参数，在页面上打印出这个用户的详细信息，程序写的这么复杂是因为我采用了mysqli的驱动，以便能使用到 <code>multi_query</code> 方法来支持同时执行多条SQL语句，这样能更好的说明SQL注入攻击的危害性。<br><br>假设我们可以通过 <code>http://localhost/test/userinfo.php?username=plhwin</code> 这个URL来访问到具体某个会员的详情，正常情况下，如果浏览器里传入的username是合法的，那么SQL语句会执行：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>SELECT uid,username FROM user WHERE username=’plhwin’</pre><br></td><br></tr><br></tbody><br></table><br></figure>但是，如果用户在浏览器里把传入的username参数变为 <code>plhwin&#39;;SHOW TABLES-- hack</code>，也就是当URL变为 <code>http://localhost/test/userinfo.php?username=plhwin&#39;;SHOW TABLES-- hack</code> 的时候，此时我们程序实际执行的SQL语句变成了：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>SELECT uid,username FROM user WHERE username=’plhwin’;SHOW TABLES– hack’</pre><br></td><br></tr><br></tbody><br></table><br></figure><em>注意：在MySQL中，最后连续的两个减号表示忽略此SQL减号后面的语句，我本机的MySQL版本号为5.6.12，目前几乎所有SQL注入实例都是直接采用两个减号结尾，但是实际测试，这个版本号的MySQL要求两个减号后面必须要有空格才能正常注入，而浏览器是会自动删除掉URL尾部空格的，所以我们的注入会在两个减号后面统一添加任意一个字符或单词，本篇文章的SQL注入实例统一以 <code>-- hack</code> 结尾。</em><br><br>经过上面的SQL注入后，原本想要执行查询会员详情的SQL语句，此时还额外执行了 <code>SHOW TABLES;</code> 语句，这显然不是开发者的本意，此时可以在浏览器里看到页面的输出：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>Array<br>(<br>    [0] =&gt; Array<br>        (<br>            [uid] =&gt; 1<br>            [username] =&gt; plhwin<br>        )<br><br>    [1] =&gt; Array<br>        (<br>            [Tables_in_demo] =&gt; user<br>        )<br><br>)</pre><br></td><br></tr><br></tbody><br></table><br></figure>你能清晰的看到，除了会员的信息，数据库表的名字<code>user</code>也被打印在了页面上，如果作恶的黑客此时将参数换成 <code>plhwin&#39;;DROP TABLE user-- hack</code>，那将产生灾难性的严重结果，当你在浏览器中执行<code>http://localhost/test/userinfo.php?username=plhwin&#39;;DROP TABLE user-- hack</code> 这个URL后，你会发现整个 <code>user</code> 数据表都消失不见了。<br><br>通过上面的例子，大家已经认识到SQL注入攻击的危害性，但是仍然会有人心存疑问，MySQL默认驱动的<code>mysql_query</code>方法现在已经不支持多条语句同时执行了，大部分开发者怎么可能像上面的演示程序那样又麻烦又不安全。<br><br>是的，在PHP程序中，MySQL是不允许在一个<code>mysql_query</code>中使用分号执行多SQL语句的，这使得很多开发者都认为MySQL本身就不允许多语句执行了，但实际上<a href="http://dev.mysql.com/doc/refman/4.1/en/c-api-multiple-queries.html" target="_blank" rel="external">MySQL早在4.1版本就允许多语句执行</a>，通过PHP的源代码，我们发现其实只是PHP语言自身限制了这种用法，具体情况大家可以看看这篇文章「<a href="http://zone.wooyun.org/content/50" target="_blank" rel="external">PHP+MySQL多语句执行</a>」。<br><br>## 实例二<br><br>如果系统不允许同时执行多条SQL语句，那么SQL注入攻击是不是就不再这么可怕呢？答案是否定的，我们仍然以上面的user数据表，用Web网站中常用的会员登录系统来做另外一个场景实例，编写程序<code>login.php</code>，代码如下：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>&lt;?php<br>if($_POST){<br>    $link = mysql_connect(“localhost”, “root”, “root”);<br>    mysql_select_db(‘demo’, $link);<br>    $username = empty($_POST[‘username’]) ? ‘’ : $_POST[‘username’];<br>    $password = empty($_POST[‘password’]) ? ‘’ : $_POST[‘password’];<br>    $md5password = md5($password);<br>    $sql = “SELECT uid,username FROM user WHERE username=’{$username}’ AND password=’{$md5password}’”;<br>    $query = mysql_query($sql, $link);<br>    $userinfo = mysql_fetch_array($query, MYSQL_ASSOC);<br>    if(!empty($userinfo)){<br>        //登录成功，打印出会员信息<br>        echo ‘&lt;pre&gt;’,print_r($userinfo, 1),’&lt;/pre&gt;’;<br>    } else {<br>        echo “用户名不存在或密码错误！”;<br>    }<br>}<br>?&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=”utf-8”&gt;<br>    &lt;title&gt;Web登录系统SQL注入实例&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;form name=”LOGIN_FORM” method=”post” action=””&gt;<br>    登录帐号: &lt;input type=”text” name=”username” value=”” size=30 /&gt;&lt;br /&gt;&lt;br /&gt;<br>    登录密码: &lt;input type=”text” name=”password” value=”” size=30 /&gt;&lt;br /&gt;&lt;br /&gt;<br>    &lt;input type=”submit” value=”登录” /&gt;<br>    &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</pre><br></td><br></tr><br></tbody><br></table><br></figure>此时如果输入正确的用户名 <code>plhwin</code> 和密码 <code>123456</code>，执行的SQL语句为：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>SELECT uid,username FROM user WHERE username=’plhwin’ AND password=’e10adc3949ba59abbe56e057f20f883e’</pre><br></td><br></tr><br></tbody><br></table><br></figure>上面语句没有任何问题，可以看到页面打印出了登录成功后的会员信息，但如果有捣蛋鬼输入的用户名为<code>plhwin&#39; AND 1=1-- hack</code>，密码随意输入，比如<code>aaaaaa</code>，那么拼接之后的SQL查询语句就变成了如下内容：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>SELECT uid,username FROM user WHERE username=’plhwin’ AND 1=1– hack’ AND password=’0b4e7a0e5fe84ad35fb5f95b9ceeac79’</pre><br></td><br></tr><br></tbody><br></table><br></figure>执行上面的SQL语句，因为<code>1=1</code>是永远成立的条件，这意味着黑客只需要知道别人的会员名，无需知道密码就能顺利登录到系统。<br><br># 如何确定SQL注入漏洞<br><br>通过以上的实例，我们仍然还会有疑问：黑客并不知道我们程序代码的逻辑和SQL语句的写法，他是如何确定一个网站是否存在SQL注入漏洞呢？一般说来有以下2种途径：<br><br>## 1、错误提示<br><br>如果目标Web网站开启了错误显示，攻击者就可以通过反复调整发送的参数、查看页面打印的错误信息，推测出Web网站使用的数据库和开发语言等重要信息。<br><br>## 2、盲注<br><br>除非运维人员疏忽，否则大部分的Web运营网站应该都关闭了错误提示信息，此时攻击者一般会采用盲注的技巧来进行反复的尝试判断。 仍然以上面的数据表user为例，我们之前的查看会员详情页面的url地址为<code>userinfo.php?username=plhwin</code>，此时黑客分别访问<code>userinfo.php?username=plhwin&#39; AND 1=1-- hack</code>和<code>userinfo.php?username=plhwin&#39; AND 1=2-- hack</code>，如果前者访问能返回正常的信息而后者不能，就基本可以判断此网站存在SQL注入漏洞，因为后者的<code>1=2</code>这个表达式永远不成立，所以即使username传入了正确的参数也无法通过，由此可以推断这个页面存在SQL注入漏洞，并且可以通过<code>username</code>参数进行注入。<br><br># 如何防御SQL注入<br><br>对于服务器配置层面的防范，应该保证生产环境的Webserver是关闭错误信息的，比如PHP在生产环境的配置文件php.ini中的display_errors应该设置为Off，这样就关闭了错误提示，下面我们更多的从编码的角度来看看如何防范SQL注入。<br><br>上面用两个实例分析了SQL注入攻击的技巧，可以看到，但凡有SQL注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成SQL语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的「外部数据不可信任」的原则，纵观Web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到的，就是从变量的检测、过滤、验证下手，确保变量是开发者所预想的。<br><br>## 1、检查变量数据类型和格式<br><br>如果你的SQL语句是类似<code>where id={$id}</code>这种形式，数据库里所有的id都是数字，那么就应该在SQL被执行前，检查确保变量id是int类型；如果是接受邮箱，那就应该检查并严格确保变量一定是邮箱的格式，其他的类型比如日期、时间等也是一个道理。总结起来：<strong>只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式</strong>，这样很大程度上可以避免SQL注入攻击。<br><br>比如，我们前面接受<code>username</code>参数例子中，我们的产品设计应该是在用户注册的一开始，就有一个用户名的规则，比如<code>5-20个字符，只能由大小写字母、数字以及一些安全的符号组成，不包含特殊字符</code>。此时我们应该有一个<code>check_username</code>的函数来进行统一的检查。不过，仍然有很多例外情况并不能应用到这一准则，比如文章发布系统，评论系统等必须要允许用户提交任意字符串的场景，这就需要采用过滤等其他方案了。<br><br>## 2、过滤特殊符号<br><br>对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。以PHP为例，通常是采用<code>addslashes</code>函数，它会在指定的预定义字符前添加反斜杠转义，这些预定义的字符是：<code>单引号 (&#39;) 双引号 (&quot;) 反斜杠 (\) NULL</code>。<br><br>来看2条SQL语句：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>$uid = isset($_GET[‘uid’]) ? $_GET[‘uid’] : 0;<br>$uid = addslashes(uid);<br>$sql = “SELECT uid,username FROM user WHERE uid=’{$uid}’”;</pre><br></td><br></tr><br></tbody><br></table><br></figure>以及<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>$uid = isset($_GET[‘uid’]) ? $_GET[‘uid’] : 0;<br>$uid = addslashes(uid);<br>$sql = “SELECT uid,username FROM user WHERE uid={$uid}”;</pre><br></td><br></tr><br></tbody><br></table><br></figure>上面两个查询语句都经过了php的addslashes函数过滤转义，但在安全性上却大不相同，在MySQL中，对于int类型字段的条件查询，上面个语句的查询效果完全一样，由于第一句SQL的变量被单引号包含起来，SQL注入的时候，黑客面临的首要问题是必须要先闭合前面的单引号，这样才能使后面的语句作为SQL执行，并且还要注释掉原SQL语句中的后面的单引号，这样才可以成功注入，由于代码里使用了addslashes函数，黑客的攻击会无从下手，但第二句没有用引号包含变量，那黑客也不用考虑去闭合、注释，所以即便同样采用addslashes转义，也还是存在SQL攻击漏洞。<br><br>对于PHP程序+MySQL构架的程序，在动态的SQL语句中，使用单引号把变量包含起来配合<code>addslashes</code>函数是应对SQL注入攻击的有效手段，但这做的还不够，像上面的2条SQL语句，根据「检查数据类型」的原则，uid都应该经过<code>intval</code>函数格式为int型，这样不仅能有效避免第二条语句的SQL注入漏洞，还能使得程序看起来更自然，尤其是在NoSQL(如MongoDB)中，变量类型一定要与字段类型相匹配才可以。<br><br>从上面可以看出，第二个SQL语句是有漏洞的，不过由于使用了addslashes函数，你会发现黑客的攻击语句也存在不能使用特殊符号的条件限制，类似<code>where username=&#39;plhwin&#39;</code>这样的攻击语句是没法执行的，但是黑客可以将字符串转为16进制编码数据或使用<code>char</code>函数进行转化，同样能达到相同的目的，如果对这部分内容感兴趣，可以<a href="http://cbb.sjtu.edu.cn/course/database/lab8.htm" target="_blank" rel="external">点击这里查看</a>。而且由于SQL保留关键字，如「HAVING」、「ORDER BY」的存在，即使是基于黑白名单的过滤方法仍然会有或多或少问题，那么是否还有其他方法来防御SQL注入呢？<br><br>## 3、绑定变量，使用预编译语句<br><br>MySQL的<code>mysqli</code>驱动提供了预编译语句的支持，不同的程序语言，都分别有使用预编译语句的方法，我们这里仍然以PHP为例，编写<code>userinfo2.php</code>代码：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>&lt;?php<br>header(‘Content-type:text/html; charset=UTF-8’);<br>$username = isset($_GET[‘username’]) ? $_GET[‘username’] : ‘’;<br>$userinfo = array();<br>if($username){<br>    //使用mysqli驱动连接demo数据库<br>    $mysqli = new mysqli(“localhost”, “root”, “root”, ‘demo’);<br>    //使用问号替代变量位置<br>    $sql = “SELECT uid,username FROM user WHERE username=?”;<br>    $stmt = $mysqli-&gt;prepare($sql);<br>    //绑定变量<br>    $stmt-&gt;bind_param(“s”, $username);<br>    $stmt-&gt;execute();<br>    $stmt-&gt;bind_result($uid, $username);<br>    while ($stmt-&gt;fetch()) {<br>        $row = array();<br>        $row[‘uid’] = $uid;<br>        $row[‘username’] = $username;<br>        $userinfo[] = $row;<br>    }<br>}<br>echo ‘&lt;pre&gt;’,print_r($userinfo, 1),’&lt;/pre&gt;’;</pre><br></td><br></tr><br></tbody><br></table><br></figure>从上面的代码可以看到，我们程序里并没有使用<code>addslashes</code>函数，但是浏览器里运行<code>http://localhost/test/userinfo2.php?username=plhwin&#39; AND 1=1-- hack</code>里得不到任何结果，说明SQL漏洞在这个程序里并不存在。<br><br>实际上，绑定变量使用预编译语句是预防SQL注入的最佳方式，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号<code>?</code>表示，黑客即使本事再大，也无法改变SQL语句的结构，像上面例子中，username变量传递的<code>plhwin&#39; AND 1=1-- hack</code>参数，也只会当作username字符串来解释查询，从根本上杜绝了SQL注入攻击的发生。<br><br># 数据库信息加密安全<br><br>相信大家都还对2011年爆出的CSDN拖库事件记忆犹新，这件事情导致CSDN处在风口浪尖被大家痛骂的原因就在于他们竟然明文存储用户的密码，这引发了科技界对用户信息安全尤其是密码安全的强烈关注，我们在防范SQL注入的发生的同时，也应该未雨绸缪，说不定下一个被拖库的就是你，谁知道呢。<br><br>在Web开发中，传统的加解密大致可以分为三种:<br><br>1、对称加密：即加密方和解密方都使用相同的加密算法和密钥，这种方案的密钥的保存非常关键，因为算法是公开的，而密钥是保密的，一旦密匙泄露，黑客仍然可以轻易解密。常见的对称加密算法有：<code>AES</code>、<code>DES</code>等。<br><br>2、非对称加密：即使用不同的密钥来进行加解密，密钥被分为公钥和私钥，用私钥加密的数据必须使用公钥来解密，同样用公钥加密的数据必须用对应的私钥来解密，常见的非对称加密算法有：<code>RSA</code>等。<br><br>3、不可逆加密：利用哈希算法使数据加密之后无法解密回原数据，这样的哈希算法常用的有：<code>md5</code>、<code>SHA-1</code>等。<br><br>在我们上面登录系统的示例代码中，<code>$md5password = md5($password);</code>从这句代码可以看到采用了md5的不可逆加密算法来存储密码，这也是多年来业界常用的密码加密算法，但是这仍然不安全。为什么呢？<br><br>这是因为md5加密有一个特点：同样的字符串经过md5哈希计算之后生成的加密字符串也是相同的，由于业界采用这种加密的方式由来已久，黑客们也准备了自己强大的md5彩虹表来逆向匹配加密前的字符串，这种用于逆向反推MD5加密的彩虹表在互联网上随处可见，在Google里使用<code>md5 解密</code>作为关键词搜索，一下就能找到<a href="http://www.cmd5.com/" target="_blank" rel="external">md5在线破解网站</a>，把我们插入用户数据时候的MD5加密字符串<code>e10adc3949ba59abbe56e057f20f883e</code>填入进去，瞬间就能得到加密前的密码：<code>123456</code>。当然也并不是每一个都能成功，但可以肯定的是，这个彩虹表会越来越完善。<br><br>所以，我们有迫切的需求采用更好的方法对密码数据进行不可逆加密，通常的做法是为每个用户确定不同的密码加盐（salt）后，再混合用户的真实密码进行md5加密，如以下代码：<br><br><figure><br><table><br><tbody><br><tr><br><td></td><br><td><br><pre>&lt;?php<br>//用户注册时候设置的password<br>$password = $_POST[‘password’];<br>//md5加密，传统做法直接将加密后的字符串存入数据库，但这不够，我们继续改良<br>$passwordmd5 = md5($password);<br>//为用户生成不同的密码盐，算法可以根据自己业务的需要而不同<br>$salt = substr(uniqid(rand()), -6);<br>//新的加密字符串包含了密码盐<br>$passwordmd5 = md5($passwordmd5.$salt);</pre><br></td><br></tr><br></tbody><br></table><br></figure>

<h1 id="小结">小结</h1><p>1、不要随意开启生产环境中Webserver的错误显示。<br>2、永远不要信任来自用户端的变量输入，有固定格式的变量一定要严格检查对应的格式，没有固定格式的变量需要对引号等特殊字符进行必要的过滤转义。<br>3、使用预编译绑定变量的SQL语句。<br>4、做好数据库帐号权限管理。<br>5、严格加密处理用户的机密信息。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/12/28/web-ying-yong-de-huan-cun-she-ji-mo-shi/" itemprop="url">
                  Web应用的缓存设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-12-28T15:16:44+08:00" content="2014-12-28">
              2014-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/资料文档/" itemprop="url" rel="index">
                    <span itemprop="name">资料文档</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/28/web-ying-yong-de-huan-cun-she-ji-mo-shi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/28/web-ying-yong-de-huan-cun-she-ji-mo-shi/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>from: <a href="http://robbinfan.com/blog/38/orm-cache-sumup" target="_blank" rel="external">http://robbinfan.com/blog/38/orm-cache-sumup</a></p>
<h2 id="ORM缓存引言">ORM缓存引言</h2><p>从10年前的2003年开始，在Web应用领域，ORM(对象-关系映射)框架就开始逐渐普及，并且流行开来，其中最广为人知的就是Java的开源ORM框架Hibernate，后来Hibernate也成为了EJB3的实现框架；2005年以后，ORM开始普及到其他编程语言领域，其中最有名气的是Ruby on rails框架的ORM － ActiveRecord。如今各种开源框架的ORM，乃至ODM(对象-文档关系映射，用在访问NoSQLDB)层出不穷，功能都十分强大，也很普及。</p>
<p>然而围绕ORM的性能问题，也一直有很多批评的声音。其实ORM的架构对插入缓存技术是非常容易的，我做的很多项目和产品，但凡使用ORM，缓存都是标配，性能都非常好。而且我发现业界使用ORM的案例都忽视了缓存的运用，或者说没有意识到ORM缓存可以带来巨大的性能提升。</p>
<h2 id="ORM缓存应用案例">ORM缓存应用案例</h2><p>我们去年有一个老产品重写的项目，这个产品有超过10年历史了，数据库的数据量很大，多个表都是上千万条记录，最大的表记录达到了9000万条，Web访问的请求数每天有300万左右。</p>
<p>老产品采用了传统的解决性能问题的方案：Web层采用了动态页面静态化技术，超过一定时间的文章生成静态HTML文件；对数据库进行分库分表，按年拆表。动态页面静态化和分库分表是应对大访问量和大数据量的常规手段，本身也有效。但它的缺点也很多，比方说增加了代码复杂度和维护难度，跨库运算的困难等等，这个产品的代码维护历来非常困难，导致bug很多。</p>
<p>进行产品重写的时候，我们放弃了动态页面静态化，采用了纯动态网页；放弃了分库分表，直接操作千万级，乃至近亿条记录的大表进行SQL查询；也没有采取读写分离技术，全部查询都是在单台主数据库上进行；数据库访问全部使用ActiveRecord，进行了大量的ORM缓存。上线以后的效果非常好：单台MySQL数据库服务器CPU的IO Wait低于5%；用单台1U服务器2颗4核至强CPU已经可以轻松支持每天350万动态请求量；最重要的是，插入缓存并不需要代码增加多少复杂度，可维护性非常好。</p>
<p>总之，采用ORM缓存是Web应用提升性能一种有效的思路，这种思路和传统的提升性能的解决方案有很大的不同，但它在很多应用场景(包括高度动态化的SNS类型应用)非常有效，而且不会显著增加代码复杂度，所以这也是我自己一直偏爱的方式。因此我一直很想写篇文章，结合示例代码介绍ORM缓存的编程技巧。</p>
<p>今年春节前后，我开发自己的个人网站项目，有意识的大量使用了ORM缓存技巧。对一个没多少访问量的个人站点来说，有些过度设计了，但我也想借这个机会把常用的ORM缓存设计模式写成示例代码，提供给大家参考。我的个人网站源代码是开源的，托管在github上：<a href="https://github.com/robbin/robbin_site" target="_blank" rel="external">robbin_site</a></p>
<h2 id="ORM缓存的基本理念">ORM缓存的基本理念</h2><p>我在2007年的时候写过一篇文章，分析ORM缓存的理念：<a href="http://robbinfan.com/blog/3/orm-cache" target="_blank" rel="external">ORM对象缓存探讨</a> ，所以这篇文章不展开详谈了，总结来说，ORM缓存的基本理念是：</p>
<ul>
<li>以减少数据库服务器磁盘IO为最终目的，而不是减少发送到数据库的SQL条数。实际上使用ORM，会显著增加SQL条数，有时候会成倍增加SQL。</li>
<li>数据库schema设计的取向是尽量设计 细颗粒度 的表，表和表之间用外键关联，颗粒度越细，缓存对象的单位越小，缓存的应用场景越广泛</li>
<li>尽量避免多表关联查询，尽量拆成多个表单独的主键查询，尽量多制造 n + 1 条查询，不要害怕“臭名昭著”的 n + 1 问题，实际上 n + 1 才能有效利用ORM缓存</li>
</ul>
<h2 id="利用表关联实现透明的对象缓存">利用表关联实现透明的对象缓存</h2><p>在设计数据库的schema的时候，设计多个细颗粒度的表，用外键关联起来。当通过ORM访问关联对象的时候，ORM框架会将关联对象的访问转化成用主键查询关联表，发送 n + 1条SQL。而基于主键的查询可以直接利用对象缓存。</p>
<p>我们自己开发了一个基于ActiveRecord封装的对象缓存框架：<a href="https://github.com/csdn-dev/second_level_cache" target="_blank" rel="external">second_level_cache</a> ，从这个ruby插件的名称就可以看出，实现借鉴了Hibernate的二级缓存实现。这个对象缓存的配置和使用，可以看我写的<a href="http://robbinfan.com/blog/33/activerecord-object-cache" target="_blank" rel="external">ActiveRecord对象缓存配置</a> 。</p>
<p>下面用一个实际例子来演示一下对象缓存起到的作用：访问我个人站点的首页。 这个页面的数据需要读取三张表：blogs表获取文章信息，blog_contents表获取文章内容，accounts表获取作者信息。三张表的model定义片段如下，完整代码请看<a href="https://github.com/robbin/robbin_site/tree/master/models" target="_blank" rel="external">models</a> ：</p>
<p><pre>class Account &lt; ActiveRecord::Base<br>  acts_as_cached<br>  has_many :blogs<br>end</pre></p>
<p>class Blog &lt; ActiveRecord::Base<br>  acts_as_cached<br>  belongs_to :blog_content, :dependent =&gt; :destroy<br>  belongs_to :account, :counter_cache =&gt; true<br>end</p>
<p>class BlogContent &lt; ActiveRecord::Base<br>  acts_as_cached<br>end<br>传统的做法是发送一条三表关联的查询语句，类似这样的：</p>
<p><pre>SELECT blogs.*, blog_contents.content, account.name<br>    FROM blogs<br>    LEFT JOIN blog_contents ON blogs.blog_content_id = blog_contents.id<br>    LEFT JOIN accounts ON blogs.account_id = account.id</pre><br>往往单条SQL语句就搞定了，但是复杂SQL的带来的表扫描范围可能比较大，造成的数据库服务器磁盘IO会高很多，数据库实际IO负载往往无法得到有效缓解。</p>
<p>我的做法如下，完整代码请看<a href="https://github.com/robbin/robbin_site/blob/master/app/controllers/home.rb" target="_blank" rel="external">home.rb</a> ：<br><pre>@blogs = Blog.order(‘id DESC’).page(params[:page])</pre><br>这是一条分页查询，实际发送的SQL如下：</p>
<p><pre>SELECT * FROM blogs ORDER BY id DESC LIMIT 20</pre><br>转成了单表查询，磁盘IO会小很多。至于文章内容，则是通过blog.content的对象访问获得的，由于首页抓取20篇文章，所以实际上会多出来20条主键查询SQL访问blog_contents表。就像下面这样：</p>
<p><pre>DEBUG -  BlogContent Load (0.3ms)  SELECT <code>blog_contents</code>.<em> FROM <code>blog_contents</code> WHERE <code>blog_contents</code>.<code>id</code> = 29 LIMIT 1<br>DEBUG -  BlogContent Load (0.2ms)  SELECT <code>blog_contents</code>.</em> FROM <code>blog_contents</code> WHERE <code>blog_contents</code>.<code>id</code> = 28 LIMIT 1<br>DEBUG -  BlogContent Load (1.3ms)  SELECT <code>blog_contents</code>.<em> FROM <code>blog_contents</code> WHERE <code>blog_contents</code>.<code>id</code> = 27 LIMIT 1<br>……<br>DEBUG -  BlogContent Load (0.9ms)  SELECT <code>blog_contents</code>.</em> FROM <code>blog_contents</code> WHERE <code>blog_contents</code>.<code>id</code> = 10 LIMIT 1</pre><br>但是主键查询SQL不会造成表的扫描，而且往往已经被数据库buffer缓存，所以基本不会发生数据库服务器的磁盘IO，因而总体的数据库IO负载会远远小于前者的多表联合查询。特别是当使用对象缓存之后，会缓存所有主键查询语句，这20条SQL语句往往并不会全部发生，特别是热点数据，缓存命中率很高：</p>
<p><pre>DEBUG -  Cache read: robbin/blog/29/1<br>DEBUG -  Cache read: robbin/account/1/0<br>DEBUG -  Cache read: robbin/blogcontent/29/0<br>DEBUG -  Cache read: robbin/account/1/0<br>DEBUG -  Cache read: robbin/blog/28/1<br>……<br>DEBUG -  Cache read: robbin/blogcontent/11/0<br>DEBUG -  Cache read: robbin/account/1/0<br>DEBUG -  Cache read: robbin/blog/10/1<br>DEBUG -  Cache read: robbin/blogcontent/10/0<br>DEBUG -  Cache read: robbin/account/1/0</pre><br>拆分n+1条查询的方式，看起来似乎非常违反大家的直觉，但实际上这是真理，我实践经验证明：数据库服务器的瓶颈往往是磁盘IO，而不是SQL并发数量。因此 拆分n+1条查询本质上是以增加n条SQL语句为代价，简化复杂SQL，换取数据库服务器磁盘IO的降低 当然这样做以后，对于ORM来说，有额外的好处，就是可以高效的使用缓存了。</p>
<h2 id="按照column拆表实现细粒度对象缓存">按照column拆表实现细粒度对象缓存</h2><p>数据库的瓶颈往往在磁盘IO上，所以应该尽量避免对大表的扫描。传统的拆表是按照row去拆分，保持表的体积不会过大，但是缺点是造成应用代码复杂度很高；使用ORM缓存的办法，则是按照column进行拆表，原则一般是：</p>
<ul>
<li>将大字段拆分出来，放在一个单独的表里面，表只有主键和大字段，外键放在主表当中</li>
<li>将不参与where条件和统计查询的字段拆分出来，放在独立的表中，外键放在主表当中<br>按照column拆表本质上是一个去关系化的过程。主表只保留参与关系运算的字段，将非关系型的字段剥离到关联表当中，关联表仅允许主键查询，以Key-Value DB的方式来访问。因此这种缓存设计模式本质上是一种SQLDB和NoSQLDB的混合架构设计</li>
</ul>
<p>下面看一个实际的例子：文章的内容content字段是一个大字段，该字段不能放在blogs表中，否则会造成blogs表过大，表扫描造成较多的磁盘IO。我实际做法是创建blog_contents表，保存content字段，schema简化定义如下：</p>
<p><pre>CREATE TABLE <code>blogs</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>title</code> varchar(255) NOT NULL,<br>  <code>blog_content_id</code> int(11) NOT NULL,<br>  <code>content_updated_at</code> datetime DEFAULT NULL,<br>  PRIMARY KEY (<code>id</code>),<br>);</pre></p>
<p>CREATE TABLE <code>blog_contents</code> (<br>  <code>id</code> int(11) NOT NULL AUTO_INCREMENT,<br>  <code>content</code> mediumtext NOT NULL,<br>  PRIMARY KEY (<code>id</code>)<br>);<br>blog_contents表只有content大字段，其外键保存到主表blogs的blog_content_id字段里面。</p>
<p>model定义和相关的封装如下：</p>
<p><pre>class Blog &lt; ActiveRecord::Base<br>  acts_as_cached<br>  delegate :content, :to =&gt; :blog_content, :allow_nil =&gt; true</pre></p>
<p>  def content=(value)<br>    self.blog_content ||= BlogContent.new<br>    self.blog_content.content = value<br>    self.content_updated_at = Time.now<br>  end<br>end</p>
<p>class BlogContent &lt; ActiveRecord::Base<br>  acts_as_cached<br>  validates :content, :presence =&gt; true<br>end<br>在Blog类上定义了虚拟属性content，当访问blog.content的时候，实际上会发生一条主键查询的SQL语句，获取blog_content.content内容。由于BlogContent上面定义了对象缓存acts_as_cached，只要被访问过一次，content内容就会被缓存到memcached里面。</p>
<p>这种缓存技术实际会非常有效，因为： 只要缓存足够大，所有文章内容可以全部被加载到缓存当中，无论文章内容表有多么大，你都不需要再访问数据库了 更进一步的是： 这张大表你永远都只需要通过主键进行访问，绝无可能出现表扫描的状况 为何当数据量大到9000万条记录以后，我们的系统仍然能够保持良好的性能，秘密就在于此。</p>
<p>还有一点非常重要： 使用以上两种对象缓存的设计模式，你除了需要添加一条缓存声明语句acts_as_cached以外，不需要显式编写一行代码 有效利用缓存的代价如此之低，何乐而不为呢？</p>
<p>以上两种缓存设计模式都不需要显式编写缓存代码，以下的缓存设计模式则需要编写少量的缓存代码，不过代码的增加量非常少。</p>
<h2 id="写一致性缓存">写一致性缓存</h2><p>写一致性缓存，叫做write-through cache，是一个CPU Cache借鉴过来的概念，意思是说，当数据库记录被修改以后，同时更新缓存，不必进行额外的缓存过期处理操作。但在应用系统中，我们需要一点技巧来实现写一致性缓存。来看一个例子：</p>
<p>我的网站文章原文是markdown格式的，当页面显示的时候，需要转换成html的页面，这个转换过程本身是非常消耗CPU的，我使用的是Github的markdown的库。Github为了提高性能，用C写了转换库，但如果是非常大的文章，仍然是一个耗时的过程，Ruby应用服务器的负载就会比较高。</p>
<p>我的解决办法是缓存markdown原文转换好的html页面的内容，这样当再次访问该页面的时候，就不必再次转换了，直接从缓存当中取出已经缓存好的页面内容即可，极大提升了系统性能。我的网站文章最终页的代码执行时间开销往往小于10ms，就是这个原因。代码如下：</p>
<p><pre>def md_content  # cached markdown format blog content<br>  APP_CACHE.fetch(content_cache_key) { GitHub::Markdown.to_html(content, :gfm) }<br>end</pre><br>这里存在一个如何进行缓存过期的问题，当文章内容被修改以后，应该更新缓存内容，让老的缓存过期，否则就会出现数据不一致的现象。进行缓存过期处理是比较麻烦的，我们可以利用一个技巧来实现自动缓存过期：</p>
<p><pre>def content_cache_key<br>  “#{CACHE_PREFIX}/blog_content/#{self.id}/#{content_updated_at.to_i}”<br>end</pre><br>当构造缓存对象的key的时候，我用文章内容被更新的时间来构造key值，这个文章内容更新时间用的是blogs表的content_updated_at字段，当文章被更新的时候，blogs表会进行update，更新该字段。因此每当文章内容被更新，缓存的页面内容的key就会改变，应用程序下次访问文章页面的时候，缓存就会失效，于是重新调用GitHub::Markdown.to_html(content, :gfm)生成新的页面内容。 而老的页面缓存内容再也不会被应用程序存取，根据memcached的LRU算法，当缓存填满之后，将被优先剔除。</p>
<p>除了文章内容缓存之外，文章的评论内容转换成html以后也使用了这种缓存设计模式。具体可以看相应的源代码：<a href="https://github.com/robbin/robbin_site/blob/master/models/blog_comment.rb" target="_blank" rel="external">blog_comment.rb</a></p>
<h2 id="片段缓存和过期处理">片段缓存和过期处理</h2><p>Web应用当中有大量的并非实时更新的数据，这些数据都可以使用缓存，避免每次存取的时候都进行数据库查询和运算。这种片段缓存的应用场景很多，例如：</p>
<ul>
<li>展示网站的Tag分类统计(只要没有更新文章分类，或者发布新文章，缓存一直有效)</li>
<li>输出网站RSS(只要没有发新文章，缓存一直有效)</li>
<li>网站右侧栏(如果没有新的评论或者发布新文章，则在一段时间例如一天内基本不需要更新)<br>以上应用场景都可以使用缓存，代码示例：<br><pre>def self.cached_tag_cloud<br>APP_CACHE.fetch(“#{CACHE_PREFIX}/blog_tags/tag_cloud”) do<br>self.tag_counts.sort_by(&amp;:count).reverse<br>end<br>end</pre><br>对全站文章的Tag云进行查询，对查询结果进行缓存<br><pre>&lt;% cache(“#{CACHE_PREFIX}/layout/right”, :expires_in =&gt; 1.day) do %&gt;</pre></li>
</ul>
<p>&lt;div class=”tag”&gt;<br>  &lt;% Blog.cached_tag_cloud.select {|t| t.count &gt; 2}.each do |tag| %&gt;<br>  &lt;%= link_to “#{tag.name}&lt;span&gt;#{tag.count}&lt;/span&gt;”.html_safe, url(:blog, :tag, :name =&gt; tag.name) %&gt;<br>  &lt;% end %&gt;<br>&lt;/div&gt;<br>……<br>&lt;% end %&gt;<br>对全站右侧栏页面进行缓存，过期时间是1天。</p>
<p>缓存的过期处理往往是比较麻烦的事情，但在ORM框架当中，我们可以利用model对象的回调，很容易实现缓存过期处理。我们的缓存都是和文章，以及评论相关的，所以可以直接注册Blog类和BlogComment类的回调接口，声明当对象被保存或者删除的时候调用删除方法：</p>
<p><pre>class Blog &lt; ActiveRecord::Base<br>  acts_as_cached<br>  after_save :clean_cache<br>  before_destroy :clean_cache<br>  def clean_cache<br>    APP_CACHE.delete(“#{CACHE_PREFIX}/blog_tags/tag_cloud”)   # clean tag_cloud<br>    APP_CACHE.delete(“#{CACHE_PREFIX}/rss/all”)               # clean rss cache<br>    APP_CACHE.delete(“#{CACHE_PREFIX}/layout/right”)          # clean layout right column cache in _right.erb<br>  end<br>end</pre></p>
<p>class BlogComment &lt; ActiveRecord::Base<br>  acts_as_cached<br>  after_save :clean_cache<br>  before_destroy :clean_cache<br>  def clean_cache<br>    APP_CACHE.delete(“#{CACHE_PREFIX}/layout/right”)     # clean layout right column cache in _right.erb<br>  end<br>end<br>在Blog对象的after_save和before_destroy上注册clean_cache方法，当文章被修改或者删除的时候，删除以上缓存内容。总之，可以利用ORM对象的回调接口进行缓存过期处理，而不需要到处写缓存清理代码。</p>
<h2 id="对象写入缓存">对象写入缓存</h2><p>我们通常说到缓存，总是认为缓存是提升应用读取性能的，其实缓存也可以有效的提升应用的写入性能。我们看一个常见的应用场景：记录文章点击次数这个功能。</p>
<p>文章点击次数需要每次访问文章页面的时候，都要更新文章的点击次数字段view_count，然后文章必须实时显示文章的点击次数，因此常见的读缓存模式完全无效了。每次访问都必须更新数据库，当访问量很大以后数据库是吃不消的，因此我们必须同时做到两点：</p>
<ul>
<li>每次文章页面被访问，都要实时更新文章的点击次数，并且显示出来</li>
<li>不能每次文章页面被访问，都更新数据库，否则数据库吃不消<br>对付这种应用场景，我们可以利用对象缓存的不一致，来实现对象写入缓存。原理就是每次页面展示的时候，只更新缓存中的对象，页面显示的时候优先读取缓存，但是不更新数据库，让缓存保持不一致，积累到n次，直接更新一次数据库，但绕过缓存过期操作。具体的做法可以参考<a href="https://github.com/robbin/robbin_site/blob/master/models/blog.rb" target="_blank" rel="external">blog.rb</a> ：<br><pre># blog viewer hit counter<br>def increment_view_count<br>increment(:view_count)        # add view_count += 1<br>write_second_level_cache      # update cache per hit, but do not touch db<pre><code><span class="preprocessor"># update db per <span class="number">10</span> hits</span>
</code></pre>self.class.update_all({:view_count =&gt; view_count}, :id =&gt; id) if view_count % 10 == 0<br>end</pre><br>increment(:view_count)增加view_count计数，关键代码是第2行write_second_level_cache，更新view_count之后直接写入缓存，但不更新数据库。累计10次点击，再更新一次数据库相应的字段。另外还要注意，如果blog对象不是通过主键查询，而是通过查询语句构造的，要优先读取一次缓存，保证页面点击次数的显示一致性，因此 <a href="https://github.com/robbin/robbin_site/blob/master/app/views/blog/_blog.erb" target="_blank" rel="external">_blog.erb</a> 这个页面模版文件开头有这样一段代码：<br><pre>&lt;%<h1 id="read_view_count_from_model_cache_if_model_has_been_cached-">read view_count from model cache if model has been cached.</h1>view_count = blog.view_count<br>if b = Blog.read_second_level_cache(blog.id)<br>view_count = b.view_count<br>end<br>%&gt;</pre><br>采用对象写入缓存的设计模式，就可以非常容易的实现写入操作的缓存，在这个例子当中，我们仅仅增加了一行缓存写入代码，而这个时间开销大约是1ms，就可以实现文章实时点击计数功能，是不是非常简单和巧妙？实际上我们也可以使用这种设计模式实现很多数据库写入的缓存功能。</li>
</ul>
<p>常用的ORM缓存设计模式就是以上的几种，本质上都是非常简单的编程技巧，代码的增加量和复杂度也非常低，只需要很少的代码就可以实现，但是在实际应用当中，特别是当数据量很庞大，访问量很高的时候，可以发挥惊人的效果。我们实际的系统当中，缓存命中次数:SQL查询语句，一般都是5:1左右，即每次向数据库查询一条SQL，都会在缓存当中命中5次，数据主要都是从缓存当中得到，而非来自于数据库了。</p>
<h2 id="其他缓存的使用技巧">其他缓存的使用技巧</h2><p>还有一些并非ORM特有的缓存设计模式，但是在Web应用当中也比较常见，简单提及一下：</p>
<h3 id="用数据库来实现的缓存">用数据库来实现的缓存</h3><p>在我这个网站当中，每篇文章都标记了若干tag，而tag关联关系都是保存到数据库里面的，如果每次显示文章，都需要额外查询关联表获取tag，显然会非常消耗数据库。在我使用的acts-as-taggable-on插件中，它在blogs表当中添加了一个cached_tag_list字段，保存了该文章标记的tag。当文章被修改的时候，会自动相应更新该字段，避免了每次显示文章的时候都需要去查询关联表的开销。</p>
<h3 id="HTTP客户端缓存">HTTP客户端缓存</h3><p>基于资源协议实现的HTTP客户端缓存也是一种非常有效的缓存设计模式，我在2009年写过一篇文章详细的讲解了：<a href="http://robbinfan.com/blog/13/http-cache-implement" target="_blank" rel="external">基于资源的HTTP Cache的实现介绍</a> ，所以这里就不再复述了。</p>
<h3 id="用缓存实现计数器功能">用缓存实现计数器功能</h3><p>这种设计模式有点类似于对象写入缓存，利用缓存写入的低开销来实现高性能计数器。举一个例子：用户登录为了避免遭遇密码暴力破解，我限定了每小时每IP只能尝试登录5次，如果超过5次，拒绝该IP再次尝试登录。代码实现很简单，如下：</p>
<p><pre>post :login, :map =&gt; ‘/login’ do<br>  login_tries = APP_CACHE.read(“#{CACHE_PREFIX}/login_counter/#{request.ip}”)<br>  halt 403 if login_tries &amp;&amp; login_tries.to_i &gt; 5  # reject ip if login tries is over 5 times<br>  @account = Account.new(params[:account])<br>  if login_account = Account.authenticate(@account.email, @account.password)<br>    session[:account_id] = login_account.id<br>    redirect url(:index)<br>  else</pre></p>
<pre><code><span class="comment"># retry 5 times per one hour</span>
<span class="constant">APP_CACHE</span>.increment(<span class="string">"<span class="subst">#{<span class="constant">CACHE_PREFIX</span>}</span>/login_counter/<span class="subst">#{request.ip}</span>"</span>, <span class="number">1</span>, <span class="symbol">:expires_in</span> =&amp;gt; <span class="number">1</span>.hour)
render <span class="string">'home/login'</span>
</code></pre><p>  end<br>end<br>等用户POST提交登录信息之后，先从缓存当中取该IP尝试登录次数，如果大于5次，直接拒绝掉；如果不足5次，而且登录失败，计数加1，显示再次尝试登录页面。</p>
<p>以上相关代码可以从这里获取：<a href="https://github.com/robbin/robbin_site" target="_blank" rel="external">robbin_site</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/12/28/an-quan-cun-chu-mi-ma-hashing-hai-shi-jia-mi/" itemprop="url">
                  安全存储密码：Hashing 还是加密？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-12-28T15:15:59+08:00" content="2014-12-28">
              2014-12-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/资料文档/" itemprop="url" rel="index">
                    <span itemprop="name">资料文档</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/28/an-quan-cun-chu-mi-ma-hashing-hai-shi-jia-mi/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/28/an-quan-cun-chu-mi-ma-hashing-hai-shi-jia-mi/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>一篇很不错的进行加密的文章!</p>
<p>from: <a href="http://www.oschina.net/news/52976/hashing-or-encrypt" target="_blank" rel="external">http://www.oschina.net/news/52976/hashing-or-encrypt</a></p>
<p>对于网站来说， 再没有什么比用户信息泄露更让人尴尬的了。 尤其是当存有用户密码的文件如果被黑客获取， 对网站的安全和用户的信心来说都是巨大的打击。 如最近的<a href="http://www.aqniu.com/threat-alert/2986.html" target="_blank" rel="external">Ebay泄密事件</a>和<a href="http://www.aqniu.com/threat-alert/2858.html" target="_blank" rel="external">小米的用户数据泄露事件</a>。 保证用户信息安全首先需要正确理解对于用户密码的安全控制和保护。 这里OWASP的主席Michael Coates最近的一篇关于一些基本概念的介绍能够帮助开发人员更好的理解现代Hashing算法和加密对于用户密码保护的作用。 安全牛编译如下：</p>
<p>在过去几个月， 我们看到了一些严重的数据泄露事件， Ebay和Adobe的数据泄露事件影响了几百万用户。 Snapchat也遭受到了数据泄露事件的影响。 每一次密码泄露事件后， 人们都会问同一个问题， 这些密码的存储是不是安全？ 不幸的是， 这个看上去简单的问题其实并不好回答。</p>
<p>尽管在很多情况下， Hashing和加密都能够满足安全存储的需要， 对于在线应用而言， 很多情况下， 对于用户密码的安全存储往往只有一种正确的方案。 Hashing.是通过一个不可逆的杂凑函数计算出一个Hash值， 而通过这个值无法逆向计算出输入值（比如用户密码）。 对称加密则是采用密钥进行加密计算， 这是一种可逆的运算。  任何人如果有了密钥， 就能够解密出原始明文。</p>
<p>下表是Hashing和对称加密的对比</p>
<p><table id="tablepress-1"></table></p>
<p><thead></thead></p>
<p><tr role="row"></tr></p>
<p><th role="columnheader" rowspan="1" colspan="1"></th></p>
<p><th role="columnheader" rowspan="1" colspan="1">Hashing</th></p>
<p><th role="columnheader" rowspan="1" colspan="1">对称加密</th><br><br></p>
<p><tbody role="alert"></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><td>不可逆函数</td></p>
<p><td>可逆运算</td><br></p>
<p><tr></tr></p>
<p><td>能够逆向算出初始值</td></p>
<p><td>不能</td></p>
<p><td>可以</td><br></p>
<p><tr></tr></p>
<p><td></td></p>
<p><td>对于现代杂凑算法而言， 从Hash值逆向算出输入值非常困难。 参见下面关于彩虹表，盐化等的讨论</td></p>
<p><td>对称加密就是设计来是的任何拥有密钥的人能够解密出原始明文</td><br></p>
<p><tr></tr></p>
<p><td>其他需要考虑的方面</td></p>
<p><td>杂凑算法的选择</td></p>
<p><td>加密算法的选择</td><br></p>
<p><tr></tr></p>
<p><td></td></p>
<p><td>对每个用户进行盐化</td></p>
<p><td>保护密钥</td><br></p>
<p><tr></tr></p>
<p><td></td></p>
<p><td></td></p>
<p><td></td><br><br><br><br>显示第 1 至 6 项结果，共 6 项</p>
<p>当在线应用收到一个用户名和一个密码后， 就以密码为输入到杂凑函数中去得出一个Hash值， 然后用这个Hash值与数据库中存储的该用户的密码Hash值做比较， 如果两个Hash值相同， 就可以认为用户提供了有效的用户名和密码。 采用Hashing的好处是， 应用不需要存储用户的明文密码， 只需要存储Hash值。</p>
<p><strong>在线应用如何利用密码的Hash值来认证用户</strong></p>
<p>下图就是关于采用Hashing方式的简单描述:</p>
<p>那么， 所有杂凑算法都能用吗？ 不是的， 事实上， 杂凑算法中不同的算法的差别很大， 并不是所有的杂凑算法都适合存储密码。</p>
<p>说起来可能有点出人预料， 早期的杂凑算法速度过快， 黑客们尽管不能通过Hash值逆向计算出原输入值， 但是黑客们可以通过暴力破解的方式遍历所有可能的密码组合来尝试能够能够“碰撞”到用户密码的Hash值。 为了避免这种威胁， 现代的杂凑算法能够通过多重迭代， 使得在每次Hash计算时产生一些延时， 对单次Hash计算， 这样的延时基本没有任何影响， 而对于黑客的暴力破解来说， 几百万次计算的延时能够被放大几百年， 这样到使得暴力破解基本不现实的地步。</p>
<p>在Hashing中， 最好采用针对每个用户的盐化方式， 通过对用户密码添加一个随机字符串（随机字符串可以是显式存储）， 这样可以相同的密码产生相同的Hash值， 这样， 攻击者可以下载一个巨大的存有事先计算好Hash值的查找表， 也叫做彩虹表。 通过Hash值， 反向查找对应的输入值。</p>
<p>而通过下面两个表格可以看出， 通过对不同用户进行不同的盐化， 同样的密码就会出现不同的Hash值， 这样使得攻击者利用彩虹表进行攻击变得困难。</p>
<p><strong>没有盐化</strong></p>
<p><table id="tablepress-2"></table></p>
<p><thead></thead></p>
<p><tr></tr></p>
<p><th>用户名</th></p>
<p><th>密码</th></p>
<p><th>Hash值</th><br><br></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td>Joe</td></p>
<p><td>password123</td></p>
<p><td>xyfkdl323…</td><br></p>
<p><tr></tr></p>
<p><td>Sue</td></p>
<p><td>password123</td></p>
<p><td>xyfkdl323…</td><br><br><br><br><strong>盐化后</strong></p>
<p><table id="tablepress-3"></table></p>
<p><thead></thead></p>
<p><tr></tr></p>
<p><th>用户名</th></p>
<p><th>密码</th></p>
<p><th>盐化字符串</th></p>
<p><th>Hash值</th><br><br></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td>Joe</td></p>
<p><td>password123</td></p>
<p><td>48a023jl2…</td></p>
<p><td>ied390fl2…</td><br></p>
<p><tr></tr></p>
<p><td>Sue</td></p>
<p><td>password123</td></p>
<p><td>9fh3ls321…</td></p>
<p><td>40akdl23…</td><br><br><br><br><strong>类似于账户锁定的机制对于密码存储的模式有什么影响吗？</strong></p>
<p>简单的回答， 就是， 没有影响。 对密码的安全存储是为了提供在密码文件被盗取后的防护。 黑客对于密码Hash的攻击是一种离线攻击。 也就是说， 密码文件已经被盗取， 黑客可以利用自己的计算机通过尝试不同的密码来找出密码。 由于是离线攻击， 账号锁定或者验证码之类的安全机制已经没有作用了。 这些机制只有在针对网站服务器的在线登录页面攻击时才会起作用。</p>
<p><strong>对于密码存储， 采用对称加密而不是Hashing的风险在哪里？</strong></p>
<p>对称加密的设计就是一个可逆的运算， 这意味着在线应用必须能够访问到密钥， 并且在每次密码验证时都要使用。 如果加密后的密码被窃取的话， 黑客需要获取对称加密的密钥， 而一旦密钥被破解出来， 不管是通过某种方式泄露出来， 或者一些弱的密钥被暴力方式破解出来， 所有的密码都会被黑客获得。</p>
<p><strong>总结</strong></p>
<p>对于密码的安全存储来说， 理解对称加密与Hashing的区别非常重要。 一些如PBKDF2， bcrypt以及scrypt等算法都采用的每用户盐化以及多重迭代的Hashing方式以安全存储密码。</p>
<p>互联网已经日益成为重要的用户信息存储的场所。 网站开发人员及网站老板们需要尽其所能地保证用户信息的安全。 了解如何利用现代的Hashing算法对用户密码进行基本的安全控制保护非常重要。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/10/29/gistbox-dai-ma-guan-li-gong-ju/" itemprop="url">
                  GistBox 代码管理工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-10-29T06:20:55+08:00" content="2014-10-29">
              2014-10-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/软件工具/" itemprop="url" rel="index">
                    <span itemprop="name">软件工具</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/29/gistbox-dai-ma-guan-li-gong-ju/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/29/gistbox-dai-ma-guan-li-gong-ju/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>GistBox 提供一种漂亮的方式来组织代码片段。将你的库保存到云端进行备份，再也不用担心丢失。GistBox采用标准的HTML5技术构建。</p>
<p>GistBox使用GitHub的后端，但增加了自己的标签和搜索功能层。使用Github账号登陆Gistbox可以将你的代码直接同步进来，反过来，你在GB上的所有改动也都会同步到Github上；GistBox的结构设 计清晰，从左至右分别是主导航（新建Gist，Gists入口，收藏入口-Labels）、Gists列表（Public/Private）、具体代码 区，亲们可以用Label给代码加上各种分辨标签，方便分类整理，在检索代码时可以用顶部的搜索栏，输入关键词或Label可以更快的搜索到目标代码。</p>
<p>网址:　<a href="http://www.gistboxapp.com/" title="demo" target="_blank" rel="external">http://www.gistboxapp.com/</a></p>
<p><a href="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/GistBox-gistbox.jpg" target="_blank" rel="external"><img src="http://coderzhaopeng-wordpress.stor.sinaapp.com/uploads/2014/09/GistBox-gistbox.jpg" alt="GistBox gistbox"></a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/10/28/ru-he-ti-gao-she-ji-api-de-neng-li/" itemprop="url">
                  如何提高设计 API 的能力？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-10-28T06:19:56+08:00" content="2014-10-28">
              2014-10-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/资料文档/" itemprop="url" rel="index">
                    <span itemprop="name">资料文档</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/28/ru-he-ti-gao-she-ji-api-de-neng-li/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/28/ru-he-ti-gao-she-ji-api-de-neng-li/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>from: <a href="http://z.ihu.im/u/BZp(7" target="_blank" rel="external">http://z.ihu.im/u/BZp(7</a></p>
<p>1、依赖倒置原则</p>
<p>依赖倒置的意思，是不要想象别人应该怎么用你的API、以及用你的API做什么；而是“倒”过来想，我的API对外提供了一个什么样的抽象、这个抽象是否够好、够简洁，有没有把不必要的细节暴露给用户。</p>
<p>比如说，之前我所在的公司做了个类似电子商城的东西，其它项目组做出产品，就放在这个商城里面销售。</p>
<p>那个商城团队就犯了干涉他人实现的大忌：他们非要了解其他项目组的逻辑，才知道如何才能把别人的产品上架销售。不要这样。</p>
<p>这种做法就导致两个团队耦合过重；且新产品和老产品逻辑无法兼容、甚至因为修改逻辑去迎合新产品，导致老产品销售逻辑出现问题——又因为怕老产品出现问题，于是不得不逼新产品去适应老产品的流程，而不管两者差别有多大。</p>
<p>这就导致，我们经常花1个月实现了一个新产品；为了把它上架却经常需要3个月甚至超过半年——并且，商城团队和其它项目团队都必须加班、修改逻辑，甚至经常因为商城方提出的诡异逻辑/需求而出现摩擦（这伙人傻的……我都忍不住发过几次火……</p>
<p>实在看不下去，我就给了一个方案，要求商城团队修改。</p>
<p>这个方案基于依赖倒置原则，要求商城对外提供一个商品的抽象；商品的定义是有名字有价格、通过销售转移所有权的逻辑实体。</p>
<p>如此一来，任何项目想要上架，只要给自己起个名字、定个价格、用html或某种富文本格式或商城项目组喜欢的任何格式提供一段商品介绍、最后再提供一个“所有权成功转移给xx用户”的回调接口即可。双方从此再不需要哪怕一个字的交流。</p>
<p>这个接口可以永远不修改哪怕一个字节，足以支持任何商品种类的交易。</p>
<p>（事实上，我们团队就是按这个要求写程序的。写完再和商城团队扯皮。这可以避免他们动辄增加的猪逻辑/需求影响到我们的内部结构：随便他们要什么，我们都可以弄个空逻辑或者不同商品规格搪塞过去）</p>
<p>但商城团队觉得一旦做成这样，他们以后就没事可干了，所以拒绝修改……</p>
<p>好在，后来他们集体辞职了。</p>
<p>——如果你的接口不能稳定，那么你一定违反了依赖倒置原则，或者是做了一个超烂的抽象。</p>
<p>——至于什么叫好抽象，请参考KISS原则</p>
<p>2、完整且最小原则</p>
<p>完整，就是接口的功能要完整，该有的功能必须有；最小，是接口功能没有冗余，不要接口A提供的功能，用一点外部逻辑再加上接口B或者接口B+接口C也能实现。</p>
<p>当然，这是一个比较理想化的指标。某些时候，为了易用性或者性能，是可以甚至必须做一些更简单、方便、易用，但加起来却不是最简的接口的。</p>
<p>但，这个完整且最小的接口必须找出来。它是一切的基础，也体现了开发者是否已经做出了一个清晰的抽象。</p>
<p>有了它，其它可以以后慢慢补；但如果没有这个基础，什么易用、简洁，都不过是扯淡。</p>
<p>我宁可用一个繁琐、难用、难理解，但可保证不变的接口，也不想碰做点简单的活计非常方便、易用，但根本没法实现稍难的需求、并且不能保证稳定的接口。</p>
<p>事实上，两者的差别就在于有没有好的抽象；而一旦有了好的抽象，哪怕想做得繁琐、难用、难理解，都不是容易的事。</p>
<p>总结：有了好的抽象，接口才可能稳定；然后找出完整且最小的接口，那么只要抽象不变，这个接口就绝对稳定；最后，在这个基础之上，做出易用、易理解的接口。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2014/10/27/ru-he-xie-chu-geng-hao-de-java-dai-ma/" itemprop="url">
                  如何写出更好的Java代码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2014-10-27T06:18:21+08:00" content="2014-10-27">
              2014-10-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/10/27/ru-he-xie-chu-geng-hao-de-java-dai-ma/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/10/27/ru-he-xie-chu-geng-hao-de-java-dai-ma/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>from: <a href="http://it.deepinmind.com/java/2014/05/21/better-java.html" target="_blank" rel="external">http://it.deepinmind.com/java/2014/05/21/better-java.html</a></p>
<p>Java是最流行的编程语言之一，但似乎并没有人喜欢使用它。好吧，实际上Java是一门还不错的编程语言，由于最近Java 8发布了，我决定来编辑一个如何能更好地使用Java的列表，这里面包括一些库，实践技巧以及工具。</p>
<p>这篇文章在<a href="https://github.com/cxxr/better-java" target="_blank" rel="external">GitHub</a>上也有。你可以随时在上面贡献或者添加你自己的Java使用技巧或者最佳实践。</p>
<ul>
<li><p>编码风格</p>
<ul>
<li><p>结构体</p>
<pre><code><span class="bullet">*   </span>builder模式
</code></pre><ul>
<li>依赖注入</li>
</ul>
</li>
<li>避免null值</li>
<li>不可变</li>
<li>避免过多的工具类</li>
<li><p>格式</p>
<pre><code><span class="bullet">*   </span>文档
</code></pre><ul>
<li>Stream</li>
</ul>
</li>
</ul>
</li>
<li><p>部署</p>
<ul>
<li>框架</li>
<li><p>Maven</p>
<pre><code><span class="bullet">*   </span>依赖收敛
</code></pre><ul>
<li>持续集成</li>
</ul>
</li>
<li>Maven仓储</li>
<li>配置管理</li>
</ul>
</li>
<li><p>库</p>
<ul>
<li><p>遗失的特性</p>
<pre><code><span class="bullet">*   </span>Apache Commons
</code></pre><ul>
<li>Guava</li>
<li>Gson</li>
<li>Java Tuples</li>
<li>Joda-Time</li>
<li>Lombok</li>
<li>Play framework</li>
<li>SLF4J</li>
<li><p>jOOQ</p>
</li>
<li><p>测试</p>
<ul>
<li>jUnit 4</li>
</ul>
</li>
<li>jMock</li>
<li>AssertJ</li>
</ul>
</li>
</ul>
</li>
<li><p>工具</p>
<ul>
<li><p>IntelliJ IDEA</p>
<pre><code><span class="bullet">*   </span>Chronon
</code></pre><ul>
<li>JRebel</li>
</ul>
</li>
<li>校验框架</li>
<li>Eclipse Memory Analyzer</li>
</ul>
</li>
<li><p>资源</p>
<ul>
<li>书籍</li>
<li>播客</li>
</ul>
</li>
</ul>
<h3 id="编码风格">编码风格</h3><p>传统的Java编码方式是非常啰嗦的企业级JavaBean的风格。新的风格更简洁准确，对眼睛也更好。</p>
<h4 id="结构体">结构体</h4><p>我们这些码农干的最简单的事情就是传递数据了。传统的方式就是定义一个JavaBean:</p>
<div><br><pre>public class DataHolder {<br>    private String data;<br><br>    public DataHolder() {<br>    }<br><br>    public void setData(String data) {<br>        this.data = data;<br>    }<br><br>    public String getData() {<br>        return this.data;<br>    }<br>}</pre><br></div><br>这不仅拖沓而且浪费。尽管你的IDE可以自动地生成这个，但这还是浪费。因此，<a href="http://www.javapractices.com/topic/TopicAction.do?Id=84" target="_blank" rel="external">不要这么写</a>。<br><br>相反的，我更喜欢C的结构体的风格，写出来的类只是包装数据：<br><div><br><pre>public class DataHolder {<br>    public final String data;<br><br>    public DataHolder(String data) {<br>        this.data = data;<br>    }<br>}</pre><br></div><br>这样写减少了一半的代码。不仅如此，除非你继承它，不然这个类是不可变的，由于它是不可变的，因此推断它的值就简单多了。<br><br>如果你存储的是Map或者List这些可以容易被修改的数据，你可以使用ImmutableMap或者ImmutableList，这个在不可变性这节中会有讨论。<br><br>#### Builder模式<br><br>如果你有一个相对复杂的对象，可以考虑下Builder模式。<br><br>你在对象里边创建一个子类，用来构造你的这个对象。它使用的是可修改的状态，但一旦你调用了build方法，它会生成一个不可变对象。<br><br>想象一下我们有一个非常复杂的对象DataHolder。它的构造器看起来应该是这样的：<br><div><br><pre>public class ComplicatedDataHolder {<br>    public final String data;<br>    public final int num;<br>    // lots more fields and a constructor<br><br>    public class Builder {<br>        private String data;<br>        private int num;<br><br>        public Builder data(String data) {<br>            this.data = data;<br>            return this;<br>        }<br><br>        public Builder num(int num) {<br>            this.num = num;<br>            return this;<br>        }<br><br>        public ComplicatedDataHolder build() {<br>            return new ComplicatedDataHolder(data, num); // etc<br>        }<br>    }<br>}</pre><br></div><br>现在你可以使用它了：<br><div><br><pre>final ComplicatedDataHolder cdh = new ComplicatedDataHolder.Builder()<br>    .data(“set this”)<br>    .num(523)<br>    .build();</pre><br></div><br>关于Builder的使用<a href="http://en.deepinmind.com/blog/2014/05/21/the-builder-pattern-in-practice.html" target="_blank" rel="external">这里</a>还有些更好的例子，我这里举的例子只是想让你大概感受一下。当然这会产生许多我们希望避免的样板代码，不过好处就是你有了一个不可变对象以及一个连贯接口。<br><br>#### 依赖注入<br><br>这更像是一个软件工程的章节而不是Java的，写出可测的软件的一个最佳方式就是使用依赖注入（Dependency injection，DI）。由于Java强烈鼓励使用面向对象设计 ，因此想写出可测性强的软件，你需要使用DI。<br><br>在Java中，这个通常都是用Spring框架来完成的。它有一个基于XML配置的绑定方式，并且仍然相当流行。重要的一点是你不要因为它的基于XML的配置格式而过度使用它了。在XML中应该没有任何的逻辑和控制结构。它只应该是依赖注入。<br><br>还有一个不错的方式是使用<a href="http://square.github.io/dagger/" target="_blank" rel="external">Dagger库</a>以及Google的<a href="https://code.google.com/p/google-guice/" target="_blank" rel="external">Guice</a>。它们并没有使用Spring的XML配置文件的格式，而是将注入的逻辑放到了注解和代码里。<br><br>#### 避免null值<br><br>如果有可能的话尽量避免使用null值。你可以返回一个空的集合，但不要返回null集合。如果你准备使用null的话，考虑一下@Nullable注解。IntelliJ IDEA对于@Nullable注解有内建的支持。<br><br>如果你使用的是Java 8的话，可以考虑下新的Optional类型。如果一个值可能存在也可能不存在，把它封装到Optional类里面，就像这样：<br><div><br><pre>public class FooWidget {<br>    private final String data;<br>    private final Optional&lt;Bar&gt; bar;<br><br>    public FooWidget(String data) {<br>        this(data, Optional.empty());<br>    }<br><br>    public FooWidget(String data, Optional&lt;Bar&gt; bar) {<br>        this.data = data;<br>        this.bar = bar;<br>    }<br><br>    public Optional&lt;Bar&gt; getBar() {<br>        return bar;<br>    }<br>}</pre><br></div><br>现在问题就清楚了，data是不会为null的，而bar可能为空。Optional类有一些像isPresent这样的方法，这让它感觉跟检查null没什么区别。不过有了它你可以写出这样的语句：<br><div><br><pre>final Optional&lt;FooWidget&gt; fooWidget = maybeGetFooWidget();<br>final Baz baz = fooWidget.flatMap(FooWidget::getBar)<br>                         .flatMap(BarWidget::getBaz)<br>                         .orElse(defaultBaz);</pre><br></div><br>这比使用if来检查null好多了。唯一的缺点就是标准类库中对Optional的支持并不是很好，因此你还是需要对null进行检查的。<br><br>#### 不可变<br><br>变量，类，集合，这些都应该是不可变的，除非你有更好的理由它们的确需要进行修改。<br><br>变量可以通过final来设置成不可变的：<br><div><br><pre>final FooWidget fooWidget;<br>if (condition()) {<br>    fooWidget = getWidget();<br>} else {<br>    try {<br>        fooWidget = cachedFooWidget.get();<br>    } catch (CachingException e) {<br>        log.error(“Couldn’t get cached value”, e);<br>        throw e;<br>    }<br>}<br>// fooWidget is guaranteed to be set here</pre><br></div><br>现在你可以确认fooWidget不会不小心被重新赋值了。final关键字可以和if/else块以及try/catch块配合使用。当然了，如果fooWidget对象不是不可变的，你也可以很容易地对它进行修改。<br><br>有可能的话，集合都应该尽量使用Guava的ImmutableMap, ImmutableList, or ImmutableSet类。这些类都有自己的构造器，你可以动态的创建它们，然后将它们设置成不可变的，。<br><br>要使一个类不可变，你可以将它的字段声明成不可变的（设置成final)。你也可以把类自身也设置成final的这样它就不能被扩展并且修改了，当然这是可选的。<br><br>#### 避免大量的工具类<br><br>如果你发现自己添加了许多方法到一个Util类里，你要注意了。<br><div><br><pre>public class MiscUtil {<br>    public static String frobnicateString(String base, int times) {<br>        // … etc<br>    }<br><br>    public static void throwIfCondition(boolean condition, String msg) {<br>        // … etc<br>    }<br>}</pre><br></div><br>这些类乍一看挺吸引人的，因为它们里面的这些方法不属于任何一个地方。因此你以代码重用之名将它们全都扔到这里了。<br><br>这么解决问题结果更糟。把它们放回它们原本属于的地方吧，如果你确实有一些类似的常用方法，考虑下Java 8里接口的默认方法。并且由于它们是接口，你可以实现多个方法。<br><div><br><pre>public interface Thrower {<br>    public void throwIfCondition(boolean condition, String msg) {<br>        // …<br>    }<br><br>    public void throwAorB(Throwable a, Throwable b, boolean throwA) {<br>        // …<br>    }<br>}</pre><br></div><br>这样需要使用它的类只需简单的实现下这个接口就可以了。<br><br>#### 格式<br><br>格式远比许多程序员相像的要重要的多。一致的格式说明你关注自己的代码或者对别人有所帮助？是的。不过你先不要着急为了让代码整齐点而浪费一整天的时间在那给if块加空格了。<br><br>如果你确实需要一份代码格式规范，我强烈推荐Google的<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="external">Java风格指南</a>。这份指南最精彩的部分就是<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html#s6-programming-practices" target="_blank" rel="external">编程实践</a>这节了。非常值得一读。<br><br>#### 文档<br><br>面向用户的代码编写下文档还是很重要的。这意味着你需要提供一些<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/ImmutableMap.Builder.html" target="_blank" rel="external">使用的示例</a>，同时你的变量方法和类名都应该有适当的描述信息。<br><br>结论就是不要给不需要文档的地方添加文档。如果对于某个参数你没什么可说的，或者它已经非常明显了，别写文档了。模板化的文档比没有文档更糟糕，因为它欺骗了你的用户，让他觉得这里有文档。<br><br>#### 流<br><br>Java 8有一个漂亮的流和lambda表达式的语法。你的代码可以这么写：<br><div><br><pre>final List&lt;String&gt; filtered = list.stream()<br>    .filter(s -&gt; s.startsWith(“s”))<br>    .map(s -&gt; s.toUpperCase());</pre><br></div><br>而不是这样：<br><div><br><pre>final List&lt;String&gt; filtered = Lists.newArrayList();<br>for (String str : list) {<br>    if (str.startsWith(“s”) {<br>        filtered.add(str.toUpperCase());<br>    }<br>}</pre><br></div><br>这样你能写出更连贯的代码，可读性也更强。<br><br>### 部署<br><br>正确地部署Java程序还是需要点技巧的。现在部署Java代码的主流方式有两种 ：使用框架或者使用自家摸索出来的解决方案，当然那样更灵活。<br><br>#### 框架<br><br>由于部署Java程序并不容易，因此才有了各种框架来用于部署。最好的两个是<a href="https://dropwizard.github.io/dropwizard/" target="_blank" rel="external">Dropwizard</a>以及<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="external">Spring Boot</a>。<a href="http://www.playframework.com/" target="_blank" rel="external">Play Framework</a>也可以算是一个部署框架。<br><br>这些框架都试图降低部署程序的门槛。如果你是一个Java的新手或者你需要快速把事情搞定的话，那么框架就派上用场了。单个jar的部署当然会比复杂的WAR或者EAR部署要更容易一些。<br><br>然而，这些框架的灵活性不够，并且相当顽固，因此如果这些框架的开发人员给出的方式不太适合你的项目的话，你只能自己进行配置了。<br><br>#### Maven<br><br>备选方案：<a href="http://www.gradle.org/" target="_blank" rel="external">Gradle</a>。<br><br>Maven仍然是编译，打包，运行测试的标准化工具。还有其它一些选择，比如Gradle，不过它们的采用程度远不Maven。如果你之前没用过Maven，你可以看下这个<a href="http://books.sonatype.com/mvnex-book/reference/index.html" target="_blank" rel="external">Maven的使用示例</a>。<br><br>我喜欢用一个根POM文件来包含所有的外部依赖。它看起来就像是<a href="https://gist.github.com/cxxr/10787344" target="_blank" rel="external">这样</a>。这个根POM文件只有一个外部依赖，不过如果你的产品很大的话，你可能会有很多依赖。你的根POM文件自己就应该是一个项目：它有版本控制，并且和其它的Java项目一样进行发布。<br><br>如果你觉得为每个外部依赖的修改都给POM文件打个标签（tag)有点太浪费了，那是你还没有经历过花了一个星期的时间来跟踪项目依赖错误的问题。<br><br>你的所有Maven工程都应该包含你的主POM文件以及所有的版本信息。这样的话，你能知道公司项目的每个外部依赖所选择的版本，以及所有正确的Maven插件。如果你需要引入一个外部依赖的话，大概是这样的：<br><div><br><pre>&lt;dependencies&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.third.party&lt;/groupId&gt;<br>        &lt;artifactId&gt;some-artifact&lt;/artifactId&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;</pre><br></div><br>如果你需要进行内部依赖的话，应该在项目的段中单独进行维护。不然的话，主POM文件的版本号就要疯涨了。<br><br>#### 依赖收敛<br><br>Java的一个最好的地方就是有大量的第三方库，它们无所不能。几乎每个API或者工具都有相应的Java SDK，并且可以很容易地引入到Maven中来。<br><br>所有的这些Java库自身可能又会依赖一些特定的版本的其它类库。如果你引入了大量的库，可能会出现版本冲突 ，比如说像这样：<br><div><br><pre>Foo library depends on Bar library v1.0<br>Widget library depends on Bar library v0.9</pre><br></div><br>你的工程应该引入哪个版本？<br><br>有了Maven的依赖收敛的插件后，如果你的依赖版本不一致的话，编译的时候就会报错。那么你有两种解决冲突的方案：<br><br><em>   在dependencyManagement区中显式地选择某个版本的bar。
</em>   Foo或者Widget都不要依赖Bar。<br>到底选择哪种方案取决你的具体情况： 如果你想要跟踪某个工程的版本，不依赖它是最好的。另一方面，如果你想要明确一点，你可以自己选择一个版本，不过这样的话，如果更新了其它的依赖，也得同步地修改它。<br><br>### 持续集成<br><br>很明显你需要某种持续集成的服务器来不断地编译你的SNAPSHOT版本，或者对Git分支进行构建。<br><br><a href="http://jenkins-ci.org/" target="_blank" rel="external">Jenkins</a>和<a href="https://travis-ci.org/" target="_blank" rel="external">Travis-CI</a>是你的不二选择。<br><br>代码覆盖率也很重要，<a href="http://cobertura.github.io/cobertura/" target="_blank" rel="external">Cobertura</a>有一个不错的Maven插件，并且对CI支持的也不错。当然还有其它的代码覆盖的工具，不过我用的是Cobertura。<br><br>### Maven库<br><br>你需要一个地方来存储你编译好的jar包，war包，以及EAR包，因此你需要一个代码仓库。<br><br>常见的选择是<a href="http://www.jfrog.com/" target="_blank" rel="external">Artifactory</a>或者<a href="http://www.sonatype.com/nexus" target="_blank" rel="external">Nexus</a>。两个都能用，并且各有利弊。<br><br>你应该自己进行Artifactory/Nexus的安装并且将你的依赖做一份镜像。这样不会由于下载Maven 库的时候出错了导到编译中断。<br><br>#### 配置管理<br><br>那现在你的代码可以编译了，仓库也搭建起来了，你需要把你的代码带出开发环境，走向最终的发布了。别马虎了，因为自动化执行从长远来看，好处是大大的。<br><br><a href="http://www.getchef.com/chef/" target="_blank" rel="external">Chef</a>，<a href="http://puppetlabs.com/" target="_blank" rel="external">Puppet</a>，和<a href="http://www.ansible.com/home" target="_blank" rel="external">Ansible</a>都是常见的选择。我自己也写了一个可选方案，<a href="http://www.gosquadron.com/" target="_blank" rel="external">Squadron</a>。这个嘛，当然了，我自然是希望你们能下载下它的，因为它比其它那些要好用多了。<br><br>不管你用的是哪个工具，别忘了自动化部署就好。<br><br>### 库<br><br>可能Java最好的特性就是它拥有的这些库了。下面列出了一些库，应该绝大多数人都会用得上。<br><br>Java的标准库，曾经还是很不错的，但在现在看来它也遗漏掉了很多关键的特性。<br><br>#### Apache Commons<br><br><a href="http://commons.apache.org/" target="_blank" rel="external">Apache Commons项目</a>有许多有用的功能。<br><br><em>   Commons Codec有许多有用的Base64或者16进制字符串的编解码的方法。别浪费时间自己又写一遍了。
</em>   Commons Lang是一个字符串操作，创建，字符集，以及许多工具方法的类库。<br><em>   Commons IO，你想要的文件相关的方法都在这里了。它有FileUtils.copyDirectory，FileUtils.writeStringToFile, IOUtils.readLines，等等。<br><br>#### Guava<br><br>Guava是一个非常棒的库，它就是Java标准库”所缺失的那部分”。它有很多我喜欢的地方，很难一一赘述，不过我还是想试一下。

</em>   Cache，这是一个最简单的获取内存缓存的方式了，你可以用它来缓存网络访问，磁盘访问，或者几乎所有东西。你只需实现一个CacheBuilder，告诉Guava如何创建缓存就好了。<br>*   不可变集合。这里有许多类：ImmutableMap, ImmutableList，甚至还有ImmutableSortedMultiSet，如果这就是你想要的话。<br>我还喜欢用Guava的方式来新建可变集合：<br><div><br><pre>// Instead of<br>final Map&lt;String, Widget&gt; map = new HashMap&lt;String, Widget&gt;();<br><br>// You can use<br>final Map&lt;String, Widget&gt; map = Maps.newHashMap();</pre><br></div><br>有许多像Lists, Maps, Sets的静态类，他们都更简洁易懂一些。<br><br>如果你还在坚持使用Java 6或者7的话，你可以用下<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Collections2.html" target="_blank" rel="external">Collections2</a>，它有一些诸如filter和transform的方法。没有Jvaa 8的stream的支持，你也可以用它们来写出连贯的代码。<br><br>Guava也有一些很简单的东西，比如Joiner，你可以用它来拼接字符串，还有一个类可以用来<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Uninterruptibles.html" target="_blank" rel="external">处理中断</a>。<br><br>#### Gson<br><br>Google的<a href="https://code.google.com/p/google-gson/" target="_blank" rel="external">Gson</a>是一个简单高效的JSON解析库。它是这样工作的：<br><div><br><pre>final Gson gson = new Gson();<br>final String json = gson.toJson(fooWidget);<br><br>final FooWidget newFooWidget = gson.fromJson(json, FooWidget.class);</pre><br></div><br>真的很简单，使用它会感觉非常愉快。Gson的<a href="https://sites.google.com/site/gson/gson-user-guide" target="_blank" rel="external">用户指南</a>中有更多的示例。<br><br>#### Java Tuples<br><br>我对Java一个不爽的地方就是它的标准库中居然没有元组。幸运的是， <a href="http://www.javatuples.org/" target="_blank" rel="external">Java tuples工程</a>解决了这一问题。<br><br>它也很容易使用，并且真的很赞：<br><div><br><pre>Pair&lt;String, Integer&gt; func(String input) {<br>    // something…<br>    return Pair.with(stringResult, intResult);<br>}</pre><br></div>

<h4 id="Joda-Time">Joda-Time</h4><p>Joda-Time是我用过的最好的时间库了。简直，直接，容易测试。你还想要什么？</p>
<p>这个库里我最喜欢的一个类就是Duration，因为我用它来告诉说我要等待多长时间，或者过多久我才进行重试。</p>
<h4 id="Lombok">Lombok</h4><p><a href="http://projectlombok.org/" target="_blank" rel="external">Lombok</a>是一个非常有趣的库。它通过注释来减少了Java中的饱受诟病的样板代码（注：setter,getter之类的）。</p>
<p>想给你类中的变量增加setter， getter方法？太简单了：</p>
<p><div></div></p>
<p><pre>public class Foo {<br>    @Getter @Setter private int var;<br>}</pre><br><br>现在你可以这么写了：</p>
<p><div></div></p>
<p><pre>final Foo foo = new Foo();<br>foo.setVar(5);</pre><br><br><a href="http://jnb.ociweb.com/jnb/jnbJan2010.html" target="_blank" rel="external">这里</a>还有更多的示例。我还没在生产代码中用过Lombok，不过我有点等不及了。</p>
<h4 id="Play框架">Play框架</h4><p>备选方案：<a href="https://jersey.java.net/" target="_blank" rel="external">Jersey</a>或者<a href="http://www.sparkjava.com/" target="_blank" rel="external">Spark</a></p>
<p>在Java中实现REST风格的WEB服务有两大阵营：<a href="http://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services" target="_blank" rel="external">JAX-RS</a>和其它。</p>
<p>JAX-RS是传统的方式。你使用像Jersey这样的东西来将注解和接口，实现组合到一起来实现WEB服务。这样做的好处就是，你可以通过一个接口就能很容易创建出一个调用的客户端来。</p>
<p>Play框架是在JVM上实现WEB服务的截然不同的一种方式：你有一个routes文件，然后你去实现routes中那些规则所引用到的类。它其实就是个完整的MVC框架，不过你可以只用它来实现REST服务。</p>
<p>它同时支持Java和Scala。它优先使用Scala这点可能有点令人沮丧，但是用Java进行开发的话也非常不错。</p>
<p>如果你习惯了Python里的Flask这类的微框架，那么你应该会对Spark感到很熟悉。有了Java 8它简直如虎添翼。</p>
<h4 id="SLF4J">SLF4J</h4><p>Java打印日志有许多不错的解决方案。我个人最喜欢的是SLF4J，因为它是可挺插拔的，并且可以同时混合不同的日志框架中输出的日志。有个奇怪的工程同时使用了java.util.logging, JCL, 和log4j？没问题，SLF4J就是为它而生的。</p>
<p>想入门的话，看下它的这个<a href="http://www.slf4j.org/manual.html" target="_blank" rel="external">两页的手册</a>就足够的了。</p>
<h4 id="jOOQ">jOOQ</h4><p>我不喜欢很重的ORM框架，因为我喜欢SQL。因此我写了许多的JDBC模板，但它们很难维护。jOOQ是个更不错的解决方案。</p>
<p>你可以在Java中以一种类型安全的方式来书写SQL语句：</p>
<p><div></div></p>
<p><pre>// Typesafely execute the SQL statement directly with jOOQ<br>Result&lt;Record3&lt;String, String, String&gt;&gt; result =<br>create.select(BOOK.TITLE, AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)<br>    .from(BOOK)<br>    .join(AUTHOR)<br>    .on(BOOK.AUTHOR_ID.equal(AUTHOR.ID))<br>    .where(BOOK.PUBLISHED_IN.equal(1948))<br>    .fetch();</pre><br><br>将它以及<a href="http://www.javapractices.com/topic/TopicAction.do?Id=66" target="_blank" rel="external">DAO模式</a>结合起来，你可以让数据库访问变得更简单。</p>
<h3 id="测试">测试</h3><p>测试对软件来说至关重要。下面这些库能让测试变得更加容易。</p>
<h4 id="jUnit_4">jUnit 4</h4><p>jUnit就不用介绍了。它是Java中单元测试的标准工具。</p>
<p>不过可能你还没有完全发挥jUnit的威力。jUnit还支持参数化测试，以及能让你少写很多样板代码的<a href="https://github.com/junit-team/junit/wiki/Rules" target="_blank" rel="external">测试规则</a>，还有能随机测试代码的<a href="https://github.com/junit-team/junit/wiki/Theories" target="_blank" rel="external">Theory</a>,以及<a href="https://github.com/junit-team/junit/wiki/Assumptions-with-assume" target="_blank" rel="external">Assumptions</a>。</p>
<h4 id="jMock">jMock</h4><p>如果你已经完成了依赖注入，那么它回报你的时候来了：你可以mock出带副作用的代码（就像和REST服务器通信那样），并且仍然能对调用它的代码执行断言操作。</p>
<p>jMock是Java中标准的mock工具。它的使用方式是这样的：</p>
<p><div></div></p>
<p><pre>public class FooWidgetTest {<br>    private Mockery context = new Mockery();</pre></p>
<pre><code><span class="keyword">@Test</span>
<span class="keyword">public</span> <span class="keyword">void</span> basicTest() {
    <span class="keyword">final</span> FooWidgetDependency dep = context.mock(FooWidgetDependency.<span class="keyword">class</span>);

    context.checking(<span class="keyword">new</span> Expectations() {
        oneOf(dep).call(<span class="keyword">with</span>(any(String.<span class="keyword">class</span>)));
        atLeast(<span class="number">0</span>).of(dep).optionalCall();
    });

    <span class="keyword">final</span> FooWidget foo = <span class="keyword">new</span> FooWidget(dep);

    Assert.assertTrue(foo.doThing());
    context.assertIsSatisfied();
}
</code></pre><p>}<br><br>这段代码通过jMock设置了一个FooWidgetDependency ，然后添加了一些期望的操作。我们希望dep的call方法被调用一次而dep的optionalCall 方法会被调用0或更多次。</p>
<p>如果你反复的构造同样的FooWidgetDependency，你应该把它放到一个<a href="https://github.com/junit-team/junit/wiki/Test-fixtures" target="_blank" rel="external">测试设备（Test Fixture）</a>里，然后把assertIsSatisfied放到一个@After方法中。</p>
<h4 id="AssertJ">AssertJ</h4><p>你是不是用jUnit写过这些？</p>
<p><div></div></p>
<p><pre>final List&lt;String&gt; result = some.testMethod();<br>assertEquals(4, result.size());<br>assertTrue(result.contains(“some result”));<br>assertTrue(result.contains(“some other result”));<br>assertFalse(result.contains(“shouldn’t be here”));</pre><br><br>这些样板代码有点太聒噪了。AssertJ解决了这个问题。同样的代码可以变成这样：</p>
<p><div></div></p>
<p><pre>assertThat(some.testMethod()).hasSize(4)<br>                             .contains(“some result”, “some other result”)<br>                             .doesNotContain(“shouldn’t be here”);</pre><br><br>连贯接口让你的测试代码可读性更强了。代码如此，夫复何求？</p>
<h3 id="工具">工具</h3><h4 id="IntelliJ_IDEA">IntelliJ IDEA</h4><p>备选方案： Eclipse and Netbeans</p>
<p>最好的Java IDE当然是 IntelliJ IDEA。它有许多很棒的特性，我们之所以还能忍受Java这些冗长的代码，它起了很大的作用。自动补全很棒，&lt; a href=”<a href="http://i.imgur.com/92ztcCd.png" target="_blank" rel="external">http://i.imgur.com/92ztcCd.png</a>“ target=”_blank”&gt;代码检查也超赞，重构工具也非常实用。</p>
<p>免费的社区版对我来说已经足够了，不过在旗舰版中有许多不错的特性比如数据库工具，Srping框架的支持以及Chronon等。</p>
<h4 id="Chronon">Chronon</h4><p>GDB 7中我最喜欢的特性就是调试的时候可以按时间进行遍历了。有了IntelliJ IDEA的<a href="http://blog.jetbrains.com/idea/2014/03/try-chronon-debugger-with-intellij-idea-13-1-eap/" target="_blank" rel="external">Chronon插件</a>后，这个也成为现实了。当然你得是旗舰版的。</p>
<p>你可以获取到变量的历史值，跳回前面执行的地方，获取方法的调用历史等等。第一次使用的话会感觉有点怪，但它能帮忙你调试一些很棘手的BUG。</p>
<h4 id="JRebel">JRebel</h4><p>持续集成通常都是SaaS产品的一个目标。你想想如果你甚至都不需要等到编译完成就可以看到代码的更新？</p>
<p>这就是<a href="http://zeroturnaround.com/software/jrebel/" target="_blank" rel="external">JRebel</a>在做的事情。只要你把你的服务器挂到某个JRebel客户端上，代码一旦有改动你马上就能看到效果。当你想快速体验一个功能的话，这个的确能节省不少时间。</p>
<h4 id="验证框架">验证框架</h4><p>Java的类型系统是相当弱的。它不能区分出普通字符串以及实际上是正则的字符串，也不能进行</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/77/">77</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="赵鹏" itemprop="image"/>
          <p class="site-author-name" itemprop="name">赵鹏</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">766</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">49</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhaopengme" target="_blank">
                  <i class="fa fa-github"></i> github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/joypen" target="_blank">
                  <i class="fa fa-weibo"></i> weibo
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
                <a href="http://www.cobmw.com/" target="_blank">记忆碎片</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.itoldme.net/" target="_blank">墙外的梯子</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.versun.org/" target="_blank">versun</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.liangxin.name" target="_blank">心岛博客</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.imf7.com/" target="_blank">付琦的博客</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.itblog.me/" target="_blank">it技术博客</a>
              </span>
            
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2008 - 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵鹏</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="http://cdn.zhaopeng.me/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhaopengme"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  
  
  <script type="text/javascript" src="http://cdn.zhaopeng.me/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="http://cdn.zhaopeng.me/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="http://cdn.zhaopeng.me/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="http://cdn.zhaopeng.me/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="http://cdn.zhaopeng.me/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="http://cdn.zhaopeng.me/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="http://cdn.zhaopeng.me/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="http://cdn.zhaopeng.me/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="http://cdn.zhaopeng.me/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "http://cdn.zhaopeng.me/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
